// This file is auto generated by the protocol-buffers compiler

/* eslint-disable quotes */
/* eslint-disable indent */
/* eslint-disable no-redeclare */
/* eslint-disable camelcase */

// Remember to `npm install --save protocol-buffers-encodings`
import encodings from 'protocol-buffers-encodings';
const varint = encodings.varint;
const skip = encodings.skip;

export const Msg1 = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
};

defineMsg1();

function defineMsg1() {
  Msg1.encodingLength = encodingLength;
  Msg1.encode = encode;
  Msg1.decode = decode;

  function encodingLength(obj) {
    let length = 0;
    if (defined(obj.f0)) {
      const len = encodings.float.encodingLength(obj.f0);
      length += 1 + len;
    }
    if (defined(obj.f1)) {
      const len = encodings.float.encodingLength(obj.f1);
      length += 1 + len;
    }
    if (defined(obj.f2)) {
      const len = encodings.float.encodingLength(obj.f2);
      length += 1 + len;
    }
    if (defined(obj.f3)) {
      const len = encodings.float.encodingLength(obj.f3);
      length += 1 + len;
    }
    if (defined(obj.f4)) {
      const len = encodings.float.encodingLength(obj.f4);
      length += 1 + len;
    }
    return length;
  }

  function encode(obj, buf, offset = 0) {
    if (!buf) buf = new Uint8Array(encodingLength(obj));
    const oldOffset = offset;
    if (defined(obj.f0)) {
      buf[offset++] = 13;
      encodings.float.encode(obj.f0, buf, offset);
      offset += encodings.float.encode.bytes;
    }
    if (defined(obj.f1)) {
      buf[offset++] = 21;
      encodings.float.encode(obj.f1, buf, offset);
      offset += encodings.float.encode.bytes;
    }
    if (defined(obj.f2)) {
      buf[offset++] = 29;
      encodings.float.encode(obj.f2, buf, offset);
      offset += encodings.float.encode.bytes;
    }
    if (defined(obj.f3)) {
      buf[offset++] = 37;
      encodings.float.encode(obj.f3, buf, offset);
      offset += encodings.float.encode.bytes;
    }
    if (defined(obj.f4)) {
      buf[offset++] = 45;
      encodings.float.encode(obj.f4, buf, offset);
      offset += encodings.float.encode.bytes;
    }
    encode.bytes = offset - oldOffset;
    return buf;
  }

  function decode(buf, offset = 0, end = buf.length) {
    if (!(end <= buf.length && offset <= buf.length)) {
      throw new Error('Decoded message is not valid');
    }
    const oldOffset = offset;
    const obj = {
      f0: 0,
      f1: 0,
      f2: 0,
      f3: 0,
      f4: 0
    };

    while (offset < end) {
      const prefix = varint.decode(buf, offset);
      offset += varint.decode.bytes;
      const tag = prefix >> 3;

      switch (tag) {
        case 1:
          obj.f0 = encodings.float.decode(buf, offset);
          offset += encodings.float.decode.bytes;
          break;
        case 2:
          obj.f1 = encodings.float.decode(buf, offset);
          offset += encodings.float.decode.bytes;
          break;
        case 3:
          obj.f2 = encodings.float.decode(buf, offset);
          offset += encodings.float.decode.bytes;
          break;
        case 4:
          obj.f3 = encodings.float.decode(buf, offset);
          offset += encodings.float.decode.bytes;
          break;
        case 5:
          obj.f4 = encodings.float.decode(buf, offset);
          offset += encodings.float.decode.bytes;
          break;
        default:
          offset = skip(prefix & 7, buf, offset);
      }
    }

    decode.bytes = offset - oldOffset;
    return obj;
  }
}

function defined(val) {
  return val !== null && val !== undefined && (typeof val !== 'number' || !isNaN(val));
}
